import React from 'react';
//import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
import SidebarComponent from './sidebar/sidebar';
import EditorComponent from './editor/editor';
import './App.css';
//import LoginHeader from './LoginHeader/LoginHeader';
  
import { Router, Route } from "react-router-dom";
import history from "./history";
import UserProvider from "./contexts/UserProvider";
import Home from "./pages/Home";
import Profile from "./pages/Profile";
import MenuBar from "./components/menus/MenuBar";

const firebase = require('firebase');

// Make sure you add an import for the css objects!
/*import DaikieM from './components/DaikieM';*/
class App extends React.Component {
  constructor() {
    super();
    this.state = {
      selectedFileIndex: null,
      selectedFile: null,
      notes: null
    };
  }
  render(){
    return(
      //in react we can return one element but we can have components inside the element
      <div className = "app-container">
        <Router history={history}>
            <UserProvider>
                <Route path="/" component={MenuBar} />
                <Route path="/profile" component={Profile} />
            </UserProvider>
            <Route path="/" exact component={Home} />
        </Router>

       
       
        <SidebarComponent 
          selectedFileIndex = {this.state.selectedFileIndex}
          notes={this.state.notes}
          deleteFile={this.deleteFile}
          selectFile={this.selectFile}
          newFile={this.newFile}></SidebarComponent>
        {
          this.state.selectedFile?
          <EditorComponent  /// call editor.js here
          selectedFile={this.state.selectedFile}
          selectedFileIndex={this.state.selectedFileIndex}
          notes={this.state.notes}
          fileUpdate={this.fileUpdate} 
          

          ></EditorComponent> : null // else the editor is empty until a file is clicked or created
         
         }

         


      </div>
      );
  }
  
  componentDidMount = () => {

    firebase
      .firestore()
      .collection('notes')/*very similar to a table in a database*/
      .onSnapshot(serverUpdate => {
          const notes = serverUpdate.docs.map(_doc => { 
          const data = _doc.data();
          data['id'] = _doc.id;
          return data;
        });/*makes an array of all the notes*/ 
        console.log(notes);
        this.setState({notes: notes}); /*we want to update our state here*/
      });/*passed a argument called sev*/

  }


  selectFile = (note, index) => this.setState({ selectedFileIndex: index, selectedFile: note });
  fileUpdate = (id, noteObj) =>{ 
    //console.log(id, noteObj); 
    firebase
      .firestore()
      .collection('notes')
      .doc(id)
      .update({ // object inside document is gonna be a title and a body
        title: noteObj.title,
        body: noteObj.body,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()//firebase function that willl generate a time stamp for us on the server
      });
  }
  // function will be async and accept a title, boy will be empty and just accept a title
  newFile = async (title) => {
    const note = {
      title: title,
      body: `<code><pre>	public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
    </pre></code>` // empty the body 
    }
    const newFromDB = await firebase // await a firebase call. creating this in firebase. then whatever response is from server is being set to equal the variable newFromDB
      //waiting for these below from the server
      .firestore()
      .collection('notes') // collection is notes
      .add({ // add an item to the collection. 
        title: note.title,
        body: note.body,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()

      });
    const newID = newFromDB.id; // access to document id generated by firebase. will need id for the application
    await this.setState({notes: [...this.state.notes, note]}); //update notes array with the spread operator [] 
    const newNoteIndex = this.state.notes.indexOf(this.state.notes.filter(_note => _note.id === newID)[0]); //indexOf() finds particallar item found inside array, pass it the actual item inside array. whats passed inside is looking for the newID passed above
    this.setState({ selectedFile: this.state.notes[newNoteIndex], selectedFileIndex: newNoteIndex}); // when we create a new file, we want to go to firebase and add the new file to firebase. and then update the currently selected file with the file we just updated 
    
  }
  //   fileUpdate = () =>{} declaing a fucntion to call in side the div
  // delete the file function below
  deleteFile = async (note) => {
    const noteIndex = this.state.notes.indexOf(note);
    await this.setState({ notes: this.state.notes.filter(_note => _note !== note) });// update the state before hand. 
    // await is part of async.  notes.filter(return all of the notes except for the note we are passing in)
    if(this.state.selectedFileIndex === noteIndex){
      this.setState({ selectedFileIndex: null, selectedFile: null }); // deslect
    } else { 
      this.state.notes.length > 1 ?
      this.selectFile(this.state.notes[this.state.selectedFileIndex - 1], this.state.selectedFileIndex - 1) : // the reason why its minus one is because its 1 less. this will account for however many file indexes are left over after deleting a file. without accounting for -1, deleting will cause errorsr
      this.setState({ selectedFileIndex: null, selectedFile: null }); // else we have no more notes and deselect everything
    
    }

    //funciton to update firebase
    firebase
      .firestore()
      .collection('notes')
      .doc(note.id) // passing which file id to delete
      .delete();
    }
  

}

export default App;
/*
function App() {
  return (
    <div className="app">
      <header class="header"><Topbar /></header>
      <div className="app_body">
  
  
        <Sidebar />
        <Chat />
      
      </div>
    </div>
  );
}
*/ 
